<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on 专注于Java、Golang、软件架构、项目管理</title>
        <link>http://localhost:1313/posts/</link>
        <description>Recent content in Posts on 专注于Java、Golang、软件架构、项目管理</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Fri, 24 May 2024 17:58:43 +0800</lastBuildDate><atom:link href="http://localhost:1313/posts/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Pingora网关</title>
        <link>http://localhost:1313/posts/rust/pingora01/</link>
        <pubDate>Fri, 24 May 2024 17:58:43 +0800</pubDate>
        
        <guid>http://localhost:1313/posts/rust/pingora01/</guid>
        <description>欣闻cloudflare开源了他们的反向代理或者说微服务网关组件 Pingora - https://github.com/cloudflare/pingora 如下，是pingora网关反向代理与缓存核心代码 pingora-proxy/src/proxy_trait.rs v0.3.0 1 2 3 4 5 6 7 8 9</description>
        </item>
        <item>
        <title>java使用虚拟线程遇到的问题</title>
        <link>http://localhost:1313/posts/java/virtualthreads/</link>
        <pubDate>Tue, 12 Dec 2023 12:22:44 +0800</pubDate>
        
        <guid>http://localhost:1313/posts/java/virtualthreads/</guid>
        <description>虚拟线程 虚拟线程（Virtual Thread）是 JDK 而不是 OS 实现的轻量级线程，由 JVM 调度。许多虚拟线程共享同一个操作系统线程，虚拟线程的数量可以</description>
        </item>
        <item>
        <title>升级到springboot3与jdk21需要做的工作</title>
        <link>http://localhost:1313/posts/java/springboot3jdk21/</link>
        <pubDate>Tue, 12 Sep 2023 12:22:44 +0800</pubDate>
        
        <guid>http://localhost:1313/posts/java/springboot3jdk21/</guid>
        <description>随着springboot3的正式版推出，最小可用的jdk版本为17。最大的亮点是颠覆性的zgc，可以将stw时间控制在亚毫秒级别，接着jdk</description>
        </item>
        <item>
        <title>Go1.18：新的切片扩容策略</title>
        <link>http://localhost:1313/posts/golang/go118-new-growslice/</link>
        <pubDate>Sun, 27 Mar 2022 14:04:09 +0800</pubDate>
        
        <guid>http://localhost:1313/posts/golang/go118-new-growslice/</guid>
        <description>随着go 1.18版本的发布，go社区终于迎来了期盼已久的正式泛型语法，然而我在浏览关于1.18的changelog时发现1.18对于slic</description>
        </item>
        <item>
        <title>nacos客户端是如何进行服务发现的？</title>
        <link>http://localhost:1313/posts/java/sca02/</link>
        <pubDate>Tue, 02 Jun 2020 22:00:00 +0800</pubDate>
        
        <guid>http://localhost:1313/posts/java/sca02/</guid>
        <description>本来自己写了一遍，但从网上找到的一个源码分析图。觉得比自己总结的好且更为细致，就直接放过来了。一图胜千言。 https://xie.infoq.cn/article/d342a914b8754dd52f5709b43 服务心跳、服务剔除 这些都与eur</description>
        </item>
        <item>
        <title>nacos注册中心初始化</title>
        <link>http://localhost:1313/posts/java/sca01/</link>
        <pubDate>Mon, 01 Jun 2020 21:00:00 +0800</pubDate>
        
        <guid>http://localhost:1313/posts/java/sca01/</guid>
        <description>注册中心启动类就一个springboot应用，看不出什么东西 1 2 3 4 5 6 7 8 @EnableScheduling @SpringBootApplication(scanBasePackages = {&amp;#34;com.alibaba.nacos.naming&amp;#34;, &amp;#34;com.alibaba.nacos.core&amp;#34;}) public class NamingApp { public static void main(String[] args) { SpringApplication.run(NamingApp.class, args); } } 通过官方文档已经一些分析，</description>
        </item>
        <item>
        <title>SpringCloud源码| zuul源码</title>
        <link>http://localhost:1313/posts/java/sc06/</link>
        <pubDate>Fri, 13 Dec 2019 21:00:00 +0800</pubDate>
        
        <guid>http://localhost:1313/posts/java/sc06/</guid>
        <description>zuul主要使用责任链设计模式 其中有如下过滤器 pre过滤器 -3：ServletDetectionFilter -2：Servlet30Wrap</description>
        </item>
        <item>
        <title>事务隔离级别，MVCC与国内主流分布式事务方案</title>
        <link>http://localhost:1313/posts/java/sc07/</link>
        <pubDate>Thu, 11 Jun 2015 21:00:00 +0800</pubDate>
        
        <guid>http://localhost:1313/posts/java/sc07/</guid>
        <description>ACID与隔离级别 事务具有以下四种特征： 原子性（Atomicity） 事务包含的所有操作要么全部成功，要么全部失败回滚。 一致性（Consist</description>
        </item>
        <item>
        <title>SpringCloud源码| ribbon源码</title>
        <link>http://localhost:1313/posts/java/sc05/</link>
        <pubDate>Sat, 30 May 2015 21:00:00 +0800</pubDate>
        
        <guid>http://localhost:1313/posts/java/sc05/</guid>
        <description>ribbon的作用：一个服务部署多个实例时，负责负载均衡请求的组件 ribbon重要组件 ILoadBalancer：负载均衡器，其中包含了IR</description>
        </item>
        <item>
        <title>SpringCloud源码| hystrix源码</title>
        <link>http://localhost:1313/posts/java/sc04/</link>
        <pubDate>Sat, 23 May 2015 21:00:00 +0800</pubDate>
        
        <guid>http://localhost:1313/posts/java/sc04/</guid>
        <description>hystrix在微服务中扮演重要作用，其实现了隔离、熔断、降级等重要组件 但在spring cloud中，常与feign搭配起来使用。故本文仅包</description>
        </item>
        <item>
        <title>SpringCloud源码| feign源码</title>
        <link>http://localhost:1313/posts/java/sc03/</link>
        <pubDate>Wed, 13 May 2015 14:09:48 +0800</pubDate>
        
        <guid>http://localhost:1313/posts/java/sc03/</guid>
        <description>feign核心组件 Encoder和Decoder：编解码组件。SpringEncoder和ResponseEntityDecoder Cont</description>
        </item>
        <item>
        <title>SpringCloud源码| eureka源码</title>
        <link>http://localhost:1313/posts/java/sc02/</link>
        <pubDate>Fri, 13 Mar 2015 21:00:00 +0800</pubDate>
        
        <guid>http://localhost:1313/posts/java/sc02/</guid>
        <description>eureka server启动流程 EurekaBootStrap#contextInitialized(ServletContextEvent) 方法进行初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 @Override public void contextInitialized(ServletContextEvent event) { try { //1、初始化</description>
        </item>
        <item>
        <title>SpringCloud源码| 从单体到微服务</title>
        <link>http://localhost:1313/posts/java/sc01/</link>
        <pubDate>Fri, 12 Dec 2014 21:00:00 +0800</pubDate>
        
        <guid>http://localhost:1313/posts/java/sc01/</guid>
        <description>1、代码重复问题 拆分成多个服务，通过网络请求不同的服务。代码不再耦合重复 2、多人协作效率问题 各种专注于自己的小范围即可，代码不会与其他服务冲</description>
        </item>
        <item>
        <title>并发源码|线程池原理</title>
        <link>http://localhost:1313/posts/java/juc08/</link>
        <pubDate>Fri, 13 Jun 2014 21:00:00 +0800</pubDate>
        
        <guid>http://localhost:1313/posts/java/juc08/</guid>
        <description>线程池 线程池的意义：频繁的创建和销毁线程，性能开销比较大。线程池创建一些线程，执行完任务后不立即销毁，可以等待去执行下一个任务 线程池相关参数</description>
        </item>
        <item>
        <title>并发源码|其他并发容器</title>
        <link>http://localhost:1313/posts/java/juc07/</link>
        <pubDate>Sun, 27 Apr 2014 21:00:00 +0800</pubDate>
        
        <guid>http://localhost:1313/posts/java/juc07/</guid>
        <description>CopyOnWriteArrayList 写时复制的并发Arraylist容器，底层使用锁来实现 底层使用volatile标记array，保证并发修改后能立即可见。 另外使用Reent</description>
        </item>
        <item>
        <title>并发源码|Hashmap死循环问题与ConcurrentHashmap</title>
        <link>http://localhost:1313/posts/java/juc06/</link>
        <pubDate>Fri, 18 Apr 2014 11:00:00 +0800</pubDate>
        
        <guid>http://localhost:1313/posts/java/juc06/</guid>
        <description>jdk7hashmap死循环问题 在多线程并发环境下。不应该用此容器，而应使用线程安全的容器如ConcurrentHashmap 其死循环主要是</description>
        </item>
        <item>
        <title>并发源码|并发常用组件</title>
        <link>http://localhost:1313/posts/java/juc05/</link>
        <pubDate>Fri, 11 Apr 2014 21:00:00 +0800</pubDate>
        
        <guid>http://localhost:1313/posts/java/juc05/</guid>
        <description>CountDownLatch：同步等待多个线程完成任务的并发组件 CyclicBarrier：将工作任务给多线程分而治之的并发组件，此组件比C</description>
        </item>
        <item>
        <title>Hashmap源码</title>
        <link>http://localhost:1313/posts/java/jdk2/</link>
        <pubDate>Mon, 31 Mar 2014 21:00:00 +0800</pubDate>
        
        <guid>http://localhost:1313/posts/java/jdk2/</guid>
        <description>Hashmap 对key进行hash，放到数组对应的位置 p = tab[i = (n - 1) &amp;amp; hash] 。i的位置为i = (n - 1) &amp;amp; hash 从JDK8以后结构为：数组 + 链表 + 红黑树，从原来的ha</description>
        </item>
        <item>
        <title>并发源码|AQS、ReentratLock原理</title>
        <link>http://localhost:1313/posts/java/juc04/</link>
        <pubDate>Wed, 19 Mar 2014 21:00:00 +0800</pubDate>
        
        <guid>http://localhost:1313/posts/java/juc04/</guid>
        <description>AQS原理 底层使用如下组件 1 2 3 4 5 6 7 8 9 10 11 private volatile int state; //标识同步状态，第一次加锁时设置为1，若重入加锁，则state递增。释放锁时sta</description>
        </item>
        <item>
        <title>ArrayList和LinkedList集合源码</title>
        <link>http://localhost:1313/posts/java/jdk01/</link>
        <pubDate>Thu, 13 Mar 2014 21:00:00 +0800</pubDate>
        
        <guid>http://localhost:1313/posts/java/jdk01/</guid>
        <description>ArrayList 底层使用数组实现，适合插入较少 适合随机查找O(1)，原理：地址连续 扩容O(n) 源码中int newCapacity = oldCapacity + (oldCapacity &amp;raquo; 1);即扩容为原来的1.5倍 插入O(</description>
        </item>
        <item>
        <title>并发源码|Atomicxxx原理</title>
        <link>http://localhost:1313/posts/java/juc02/</link>
        <pubDate>Tue, 11 Mar 2014 21:00:00 +0800</pubDate>
        
        <guid>http://localhost:1313/posts/java/juc02/</guid>
        <description>AtomicXxx原子类底层的一些原理 AtomicLong、AtomicBoolean、AtomicReference、LongAdder等</description>
        </item>
        <item>
        <title>并发源码|synchronized、wait与notify</title>
        <link>http://localhost:1313/posts/java/juc02/</link>
        <pubDate>Sat, 08 Mar 2014 21:00:00 +0800</pubDate>
        
        <guid>http://localhost:1313/posts/java/juc02/</guid>
        <description>synchronized的底层原理 跟jvm及monitor有关。 如果用到了synchronized关键字，在底层编译后的jvm指令中，会有m</description>
        </item>
        <item>
        <title>并发源码| JMM与volatile</title>
        <link>http://localhost:1313/posts/java/juc01/</link>
        <pubDate>Sat, 01 Mar 2014 21:00:00 +0800</pubDate>
        
        <guid>http://localhost:1313/posts/java/juc01/</guid>
        <description>主内存的数据会被加载到cpu本地缓存里去，cpu后面会读写自己的缓存 缓存模型下的并发问题 java内存模型 read（从主存读取），load（将</description>
        </item>
        
    </channel>
</rss>
